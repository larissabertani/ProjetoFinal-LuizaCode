
<img src="17BF2C11.png">
<h1 align="center" id="capa"><b>Projeto final - 5ª edição LuizaCode</b></h1>

<h1 align="center"> LuizaPets Team</h1>

<h4 align="center"> Grupo 9 - Petshop </h4>
<table align="center">
  <td align="center"><br>
        <a href="https://www.linkedin.com/in/ana-vitoria-luz-546201219/">
          <img src="https://i.postimg.cc/x82zRCj2/Integrantes.png" width="90px;" alt="Ana Vitoria" style="max-width:100%;border-radius: 50%;">
            <br><sub><b>Ana Vitória Luz</b></sub><br>
         <p align="center">
         </a><br>
         <a href="https://github.com/anairotiv">
                    <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" height="20" width="20">
            </a>
             <a href="https://www.linkedin.com/in/ana-vitoria-luz-546201219/" rel="nofollow">
                 <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linkedin/linkedin-original.svg" height="20" width="20">
            </a>
             <a href="mailto:anavitoriasln@gmail.com">
                  <img src="https://user-images.githubusercontent.com/60053229/118977653-c8a76a00-b94c-11eb-8832-e815ed684ccf.png" height="20" width="20">
                  <td align="center"><br>
        <a href="https://i.postimg.cc/5N8PbYQw/Integrantes2.png">
            <img src="https://i.postimg.cc/28wTJfMh/Integrantes2.png" width="90px;" alt="Camila" style="max-width:100%;border-radius: 50%;">
            <br><sub><b>Camila Tófoli</b></sub><br>
        <p align="center">
            </a><br>
            <a href="https://github.com/camilareist">
                   <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" height="20" width="20">
            </a>
            <a href="https://www.linkedin.com/in/camilatofoli/" rel="nofollow">
                 <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linkedin/linkedin-original.svg" height="20" width="20">
            </a>
            <a href="camilartofoli@gmail.com">
                  <img src="https://user-images.githubusercontent.com/60053229/118977653-c8a76a00-b94c-11eb-8832-e815ed684ccf.png" height="20" width="20">
            </a>
       </p>
</td>
            </a>
       </p>
</td>
<td align="center"><br>
        <a href="https://i.postimg.cc/bwzRP6hh/Integrantes3.png">
            <img src="https://i.postimg.cc/g2K9N5qT/Integrantes3.png" width="90px;" alt="Larissa Bertani" style="max-width:100%;border-radius: 50%;">
            <br><sub><b>Larissa Bertani</b></sub><br>
        <p align="center">
            </a><br>
            <a href="https://github.com/larissabertani">
                   <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" height="20" width="20">
            </a>
            <a href="https://br.linkedin.com/in/larissabertani" rel="nofollow">
                 <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linkedin/linkedin-original.svg" height="20" width="20">
            </a>
            <a href="larissabertani1997@hotmail.com">
                  <img src="https://user-images.githubusercontent.com/60053229/118977653-c8a76a00-b94c-11eb-8832-e815ed684ccf.png" height="20" width="20">
            </a>
       </p>
</td>
<td align="center"><br>
        <a href="https://i.postimg.cc/wBwNk0K6/Integrantes4.png">
            <img src="https://i.postimg.cc/W44yS44d/Integrantes4.png" width="90px;" alt="Maisa Pacheco" style="max-width:100%;border-radius: 50%;">
            <br><sub><b>Maisa Pacheco</b></sub><br>
        <p align="center">
            </a><br>
            <a href="https://github.com/MaisaPacheco">
                   <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" height="20" width="20">
            </a>
            <a href="https://www.linkedin.com/in/maisapacheco/" rel="nofollow">
                 <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linkedin/linkedin-original.svg" height="20" width="20">
            </a>
            <a href="maisasoarespacheco@gmail.com">
                  <img src="https://user-images.githubusercontent.com/60053229/118977653-c8a76a00-b94c-11eb-8832-e815ed684ccf.png" height="20" width="20">
            </a>
       </p>
</td>

<td align="center"><br>
        <a href="https://i.postimg.cc/zBpxKn7W/Integrantes5.png">
            <img src="https://i.postimg.cc/J4GGwNdx/Integrantes5.png" width="90px;" alt="Siomara Murta" style="max-width:100%;border-radius: 50%;">
            <br><sub><b>Siomara Murta</b></sub><br>
        <p align="center">
            </a><br>
            <a href="https://github.com/siomaramurta">
                   <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" height="20" width="20">
            </a>
            <a href="https://www.linkedin.com/in/siomara-murta-31466362/" rel="nofollow">
                 <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/linkedin/linkedin-original.svg" height="20" width="20">
            </a>
            <a href="siomara.murta@gmail.com">
                  <img src="https://user-images.githubusercontent.com/60053229/118977653-c8a76a00-b94c-11eb-8832-e815ed684ccf.png" height="20" width="20">
            </a>
       </p>
</td>

</table>

<div align="center">
  
![ezgif com-gif-maker](https://user-images.githubusercontent.com/74475820/194670258-75e61522-a813-4063-a396-48d31784f29a.gif)

<a href="pyton">
   <img align="center" alt="node" height="40" width="40" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg">
</a>
    <a href="mongodb">
   <img align="center" alt="express" height="40" width="40" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/mongodb/mongodb-original-wordmark.svg">
</a>
  <a href="fastapi">
   <img align="center" alt="mysql" height="40" width="40" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/fastapi/fastapi-plain-wordmark.svg">
</a>
    <a href="docker">
   <img align="center" alt="sequelize" height="40" width="40" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original-wordmark.svg">
</a>
   <a href="heroku">
   <img align="center" alt="sequelize" height="40" width="40" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/heroku/heroku-plain-wordmark.svg">
</a>
  
</div>
<br/>
<img src="17BF2C11.png">

<h2>Carrinho de compras</h2> 

<h3 id="índice">Índice</h3>

* [Projeto final - 5ª edição LuizaCode](#capa)
* [Índice](#índice)
* [Descrição do Projeto](#descrição-do-projeto)
* [Pessoas Desenvolvedoras do Projeto](#pessoas-desenvolvedoras)
* [Como rodar o projeto?](#como-rodar-o-projeto)
* [Apresentação das atividades](#apresentação-das-atividades)
* [Tecnologias utilizadas](#tecnologias-utilizadas)
* [Pessoas Contribuidoras](#pessoas-contribuidoras)
* [Conclusão](#conclusao)
<br/>
<h3 id="descrição-do-projeto">Descrição do projeto</h3>

<p>Este projeto teve como objetivo o desenvolvimento de um carrinho de compras voltado ao mercado Pet utilizando o <a href="https://fastapi.tiangolo.com/">FastAPI</a> e o <a href="https://www.mongodb.com/">MongoDB</a>, tecnologias trabalhadas durante o bootcamp.</p>

<h3 id="pessoas-desenvolvedoras">Pessoas Desenvolvedoras do Projeto:</h3>

<p>- Ana Vitória Luz<br/>
- Camila Tófoli <br/>
- Larissa Bertani<br/>
- Maisa Pacheco <br/>
- Siomara Murta</p>

<h3 id="como-rodar-o-projeto">Como rodar o projeto?:</h3>
<br/>
<p> • Crie um ambiente virtual, digitando no terminal da pasta do projeto o seguinte comando: 

    $ python -m venv venv

• Ative o ambiente virtual, digitando no terminal: 

```
- Linux
$ source venv/bin/activate

- Windows
$ venv\Scripts\activate
```
• Após ativar o ambiente virtual, faça a instalação dos seguintes requerimentos com o comando: 

```
$ pip install -r requirements.txt
```
• Faça a conexão com o MongoDB, criando um arquivo .env e informando a sua string de conexão, conforme o exemplo do arquivo .env.example.

• As libs que serão utilizadas serão:
```
$ motor = Driver Python async for MongoDB
$ pydantic = Data validation for Python
```
• Para rodar a aplicação local, utilize o comando:
```
$ uvicorn main:app --reload
```
• Será necessário instalar o Docker, que poderá ser encontrado clicando <a href="https://docs.docker.com/desktop/install/windows-install/">AQUI</a>.

• Com o docker já instalado e rodando em sua máquina, você poderá acessar o projeto com os seguintes comandos:

```
- Dentro da pasta do projeto, digite no terminal:

$ docker build -t shopping-cart .

Após esse comando:

$ docker run -p 8000:8000 shopping-cart

```
• Após a executação dos comandos, será possível acessar o projeto na rota: http://127.0.0.1:8000/docs. Este link contém o swagger da aplicação. A aplicação foi hospedada no Heroku, além de ter sido feito um deploy no Docker.

<h3 id="apresentação-das-atividades">Apresentação das atividades:</h3>

<p>O projeto foi divido nas seguintes etapas:
<br/>

<p>
<a href="#gestao-do-usuario">Gestão do usuário</a> | <a href="#gestao-do-endereco-do-usuario">Gestão do endereço do usuário</a> | <a href="#gestao-dos-produtos">Gestão dos produtos</a> | <a href="#criando-um-carrinho-para-o-usuario">Criando um carrinho de compras para o usuário</a> | <a href="#formulando-pedido-fechado">Formulando um pedido fechado</a> | <a href="#testando-o-projeto">Testando o projeto</a> 
</p>

<p>E o desenvolvimeno da aplicação foi realizado dentro das seguintes pastas:

- src: Pasta principal da aplicação.
<br/>
  - models: Módulo para persistência (repositório) com o banco de dados.<br/>
  - rules: Módulos para as regras (casos de uso) da aplicação.<br/>
  - controllers: Módulos para de controle e/ou comunicação com o FastAPI.<br/>
- server: Pasta que contém o endereço das collection que serão utilizados para que sejam realizadas as rotas<br/>
- tests: contém os arquivos de configuração para que os testes possam rodar e os testes escritos:
  - test_user: testes unitários da criação dos usuários;
  - test_address: testes unitários da criação dos endereços;
  - test_product: testes unitários da criação dos produtos;
  - test_cart: testes unitários para a formação de um carrinho de compras;
  - test-order: testes unitários para a finalização de um pedido.
  </p>

<h3 id="gestao-do-usuario">Gestão do usuário</h3>

Utilizando o arquivo cases_test_user.http, criamos os esboços das APIs que foram empregados exclusivamente nos testes da etapa de gestão do usuário.

Para que fosse possível executar as rotas existentes, usamos a extensão Rest Client do Visual Code.

No arquivo user.py, que está dentro da pasta "schemas", criamos classes relacionadas ao usuário, contedo as informações necessárias para criá-lo, atualizá-lo e para obtê-lo como resposta para outras etapas da aplicação.

Já na pasta "rules", o arquivo user_rules.py abrigou as regras de negócio definida para o cadastro do usuário. Desta maneira, apenas é possível cadastrar um usuário por endereço de e-mail. Este arquivo também contém as funções para que seja possível obter uma lista de usuários, consultar um usuário por seu user_id e por seu user_email, atualizar os dados de um usuário e por fim excluí-lo do banco.

Na função de exclusão do usuário entendemos que ao retirar um cliente do sistema, os dados relacionados a ele, como o endereço, por exemplo, deveriam ser também excluídos.

Para o usuário que deseja se descadastrar, caso haja um pedido que ainda não esteja finalizado, ele também será excluído, ou seja, um carrinho de compras que esteja aberto também é excluído junto ao seu dono.

Entretanto, pedidos já finalizados devem permanecer sem alteração  para que seja possível acompanhar o detalhamento das vendas realizadas.

A pasta "models", contém também um arquivo de nome user.py e ele contém as conexões com o banco de dados, para que as funções definidas no arquivo user_rules.py tenham efeito também no banco.

Por fim, as rotas que permitem que as requisições sejam efetuadas ficam localizadas na pasta "controllers", no arquivo routes_user_async.py.

##Instruções da Gestão do usuário

Com a aplicação preparada para rodar e com a conexão com o Mongo ativa, iniciamos o cadastro de um novo usuário, usando a rota api/users/.

Para criar um usuário usamos o método POST /api/users/, se conseguirmos criar um usuário no banco de dados, o retorno será com o código HTTP 201 Created, e no corpo de resposta haverá todos os dados do usuário criado:

```json
{
  {
  "description": "OK",
  "result": {
     "_id": "<_id>",
     "name": "<name>",
     "email": "<email>",
     "password": "<password>",
     "is_active": "<is_active",
     "is_admin": "<is_admin>"
    }
  }
}
```
Havendo uma nova tentativa de cadastro com um e-mail já utilizado, a API retornará o código HTTP 202 Accepted e a mensagem informará que este usuário já possui um cadastro:

```json
{
  "detail": "Já existe um cliente cadastrado com este e-mail!"
}
```
Se desejar obter uma lista dos usuários já cadastrados no banco, será possível utilizar a requisição GET /api/users/ e se for preciso buscar um usuário no qual o e-mail é conhecido, basta utilizar o método GET /api/users/<user_email>. O retorno de ambos os endpoints é semelhante, pois devolvem o código HTTP 200 e um json com o resultado, que deverá conter uma lista de usuários ou um dicionário com os dados do usuário buscado, conforme o caso.

No momento de descadastrar um usuário, a requisição deverá ser realizada utilizando o método DELETE /api/users/<user_email>. Com o processo de exclusão finalizado, o código retornado é o HTTP 200 e a mensagem:

```json
{
  "description": "Usuário deletado com sucesso!",
  "result": null
}
```
Em uma situação de exceção, a mensagem retornada informará o código HTTP 404 Not Found e a descrição: 

```json
{
  "detail": "Não há usuário com este email para ser deletado!"
}
```

<h3 id="gestao-do-endereco-do-usuario">Gestão do endereço do usuário</h3>

Após cadastrar um usuário, é possível acrescentar informações a ele, cadastrando também um endereço que futuramente poderá ser usado para a cobrança da compra ou para o recebimento do pedido.

O arquivo cases_test_address.http, neste caso é o que contempla os esboços das APIs.

No arquivo address.py, que está dentro da pasta "schemas", criamos classes relacionadas ao endereço, contedo as informações necessárias para criá-lo, atualizá-lo e para obtê-lo como resposta para outras etapas da aplicação, como por exemplo, no fechamento do pedido.

Já na pasta "rules", o arquivo address_rules.py abrigou as regras de negócio definida para o endereço e sua manipulação. A principal regra associada a um endereço é a de que ele precisa obrigatoriamente ser associado a um usuário existente, através do e-mail do usuário, para que possa ser criado no banco de dados.

Além da criação do endereço, este arquivo também estabelece as regras para que os endereços de um usuário possam ser consultados e/ou excluídos, utilizando o e-mail do usuário como o dado para realizar a busca dos endereços.

A pasta "models", contém um arquivo de nome address.py e ele exibe as funções de conexões com o banco de dados, para que as funções definidas no arquivo address_rules.py tenham efeito também no banco.

Por fim, as rotas que permitem que as requisições sejam efetuadas ficam localizadas na pasta "controllers", no arquivo routes_addredd_async.py, assim como as de gestão do usuário.

##Instruções da Gestão do endereço do usuário

Com a aplicação preparada para rodar e com a conexão com o Mongo ativa podemos iniciar o cadastro de um endereço, após informar o e-mail de um usuário já cadastrado na aplicação. A rota que deverá ser usada é api/address/.

Para associar um endereço a um novo usuário usamos o método POST /api/address/<user_email>. Ao finalizar o cadastro, o retorno obtido será com o código HTTP 201 Created, e no corpo de resposta haverá todos os dados do usuário criado e a sua lista de endereços:


```json
{
  "description": "OK",
  "result": {
    "user": {
      "_id": "<_id>",
     "name": "<name>",
     "email": "<email>",
     "password": "<password>",
     "is_active": "<is_active",
     "is_admin": "<is_admin>"
    },
    "addresses": [
      {
        "street": "<street>",
        "number": "<number",
        "zipcode": "<zipcode",
        "district": "district",
        "city": "<city",
        "state": "<state",
        "is_delivery": "is_delivery"
      }
    ]
  }
}
```

Se desejar consultar a lista dos endereços de um usuário já cadastrado no banco, será possível utilizar a requisição GET /api/address/<user_email>. O retorno deste endpoint será uma lista contendo os endereços relacionados ao usuário pesquisado.

```json
[
  {
    "street": "<street>",
    "number": "<number",
    "zipcode": "<zipcode",
    "district": "district",
    "city": "<city",
    "state": "<state",
    "is_delivery": "is_delivery"
  }
]
```
Entretanto, se o endereço de e-mail utilizado na URL não for encontrado no banco de dados, o retorno será o código HTTP 404 Not Found e a mensagem exibida é:

```json
{
  "detail": "Não há usuário cadastrado com este email!"
}
```
Havendo necessidade de exclusão de endereços que não pertencem mais ao usuário, por exemplo, caso ele tenha se mudado, o endpoint utilizado será o DELETE /api/address/<user_email>. Para confirmar a exclusão do endereço, o código HTTP 200 é retornado junto a mensagem:

```json
{
  "description": "Endereço deletado com sucesso!",
  "result": null
}
```
Em uma situação de exceção, o código será HTTP 404 Not Found e a mensagem retornada será: 

```json
{
  "detail": "Não há endereço para ser deletado para este usuário!"
}
```

<h3 id="gestao-dos-produtos">Gestão dos produtos</h3>

A área de gestão de produtos foi desenvolvida pensando na equipe administradora do LuizaPets Team, para disponibilizar os produtos que estarão a venda.

O primeiro passo foi criar na pasta "schemas" um arquivo product.py, contendo a classe do produto. Nela definimos que o nome do produto poderá ter no máximo 100 caracteres. Também incluímos no produto o animal ao qual o produto é dedicado e a categoria do produto para que seja possível disyinguir se ele é de alimentação, higiene ou brinquedo, por exemplo.

Neste arquivo também criamos outras classes para que seja possível realizar a atualização dos dados do produto e obtê-lo como resposta para outras etapas da aplicação.

Já na pasta "rules", o arquivo product_rules.py abrigou as regras de negócio definida para o produto e sua manipulação. Há algumas regras associadas a criação do produto que são:

- Um produto deverá ter um código único;
- O preço de um produto deverá ser sempre superior a  R$ 0,01;
- Para que o produto seja cadastrado, o estoque dele deverá ser superior a 0.

Além da criação do produto, este arquivo também estabelece as regras para que os produtos possam ser consultados pelo código único ou pelo nome; para que eles possam ser atualizados ou retirados do site.

Na pasta "models", criamos o product.py que abriga as funções de conexões com o banco de dados, para que as funções definidas no arquivo produtc_rules.py tenham efeito também no banco.

Por fim, as rotas que permitem que as requisições sejam efetuadas ficam localizadas na pasta "controllers", no arquivo routes_products_async.py, assim como as demais.

##Instruções da Gestão dos produtos

Após garantir que a aplicação está preparada para rodar e com a conexão com o Mongo ativa, podemos iniciar o cadastro de um produto, usando a rota api/products/.

Para cadastrar um produto usamos o método POST /api/products. Ao finalizar o cadastro, o retorno obtido será com o código HTTP 201 Created, e no corpo de resposta haverá todos os dados do produto criado:

```json
{
  "description": "OK",
  "result": {
    "_id": "<_id>",
    "name": "<name>",
    "description": "<description>",
    "price": "<price>",
    "image": "<image>",
    "code": "<code>",
    "type_animal": "<type_animal>",
    "category": "<category>",
    "qt_stock": "<qt_stock>"
  }
}
```
Se desejar consultar os produtos pelo id, código ou nome, basta utilizar o método GET /api/products/ passando o código do item ou o nome do mesmo após o "products/".

Para buscar produtos pelo nome, caso ele tenha espaços, por exemplo "Ração LuizaPets para cães Adultos", sugerimos o uso do "%20" para substituir os espaços: Ração%20LuizaPets%20para%20cães%20Adultos.

O retorno dos endpoints de consulta será com o código HTTP 200 e um json com os dados do item pesquisado:

```json
{
  "description": "OK",
  "result": {
    "_id": "<_id>",
    "name": "<name>",
    "description": "<description>",
    "price": "<price>",
    "image": "<image>",
    "code": "<code>",
    "type_animal": "<type_animal>",
    "category": "<category>",
    "qt_stock": "<qt_stock>"
  }
}
```
Entretanto, se o produto informado na URL não for encontrado no banco de dados, o retorno será o código HTTP 404 Not Found e a mensagem exibida é:

```json
{
  "detail": "Não existe produto com este código!"
}
ou
{
  "detail": "Não existe produto com este nome!"
}
```
Havendo necessidade de atualizar os dados do produto, como no caso de uma promoção ou alterações na descrição, será possível utilizando o método PUT /api/products/<product_code> junto aos novos dados do item. Ao finalizar a atualização, o código retornado é o HTTP 200 e a mensagem é:

```json
{
  "description": "Produto alterado com sucesso!",
  "result": null
}
```
Caso o código do produto não esteja informado corretamente na requisição, será retornado código HTTP 404 Not Found e a mensagem:

```json
{
  "detail": "Não existe produto com o código informado!"
}
```
Se o produto for descontinuado, o endpoint utilizado será o DELETE /api/products/<product_code>. Para confirmar a exclusão do item, o código HTTP 200 é retornado junto a mensagem:

```json
{
  "description": "Produto deletado com sucesso!",
  "result": null
}
```
Em uma situação de exceção, o código será HTTP 404 Not Found e a mensagem retornada será: 

```json
{
  "detail": "Não há produto com este código para ser deletado!"
}
```
Nesta etapa, o arquivo cases_test_product.http, foi o que contemplou os esboços das APIs.

<h3 id="criando-um-carrinho-para-o-usuario">Criando um carrinho de compras para o usuário</h3>

Retornando aos clientes LuizaPets, iniciamos os passos para a construção de um carrinho de compras que poderá ou não se tornar um pedido em nossa loja.

Para auxiliar com as requisições, temos também um arquivo que contém os esboços das API's: cases_test_cart.

As classes relacionadas ao carrinho ficaram registradas no arquivo cart.py, dentro da pasta "schemas". A classe criada para os produtos do carrinho, herdou a classe criada para produtos e a classe para a construção do carrinho, herdou a classe do usuário.

Há também outras classes para que seja possível obtê-lo como resposta para outras etapas da aplicação, como a finalização do pedido.

Em "rules", o arquivo cart_rules.py abrigou as regras para que um usuário tivesse um carrinho. Para iniciar, somente é possível ter um carrinho um usuário que já esteja cadastrado na loja e ele somente conseguirá ser criado se adicionarmos um produto que também já esteja no banco de dados.

Após a criação de um carrinho é possível adicionar novos produtos, retirar produtos, finalizá-lo para que ele se torne um pedido ou excluí-lo, no caso de haver desistência da compra.

Na pasta "models", criamos o cart.py que abriga as funções de conexões com o banco de dados, para que as funções definidas no arquivo cart_rules.py tenham efeito também no banco.

Por fim, as rotas que permitem que as requisições sejam efetuadas ficam localizadas na pasta "controllers", no arquivo routes_pcart_async.py, assim como as demais.

##Instruções para a criação do carrinho

Após garantir que a aplicação está preparada para rodar e com a conexão com o Mongo ativa, será necessário garantir alguns passos:

- Que ao menos um usuário esteja cadastrado na loja;
- Que o usuário cadastrado possua ao menos um endereço cadastrado;
- Que ao menos um produto esteja cadastrado na loja.

Para um carrinho usamos o método POST /api/cart/<user_id>/<product_code>. A inclusão de um produto é o que cria um carrinho de compras, o retorno obtido que garante que o carrinho está criado é com o código HTTP 201 Created, e no corpo de resposta os seguintes dados:

```json
{
  "description": "OK",
  "result": {
    "user": {
      "_id": "<_id>",
      "name": "<name>",
      "email": "<email>",
      "password": "<password>",
      "is_active": "<is_active",
      "is_admin": "<is_admin>"
    },
    "cart_items": [
      {
        "product": {
          "_id": "<_id>",
          "name": "<name>",
          "description": "<description>",
          "price": "<price>",
          "image": "<image>",
          "code": "<code>",
          "type_animal": "<type_animal>",
          "category": "<category>",
          "qt_stock": "<qt_stock>",
        },
        "qtd_product": "<qtd_product>"
      }
    ],
    "total_price": "<total_price>"
  }
}
```
Caso uma das condições para a criação do carrinho não seja satisfeita, haverá o erro HTTP 404 Not Found e as mensagens poderão ser:

```json
{
  "detail": "Não existe produto com este código!"
}
ou 
{
  "detail": "Não há usuário cadastrado com este id."
}
```
Se desejar, um administrador da loja, poderá consultar o carrinho de um usuário. Para isso, ele deverá utilizar o método GET /api/cart/<user_id>.

O retorno do endpoint de consulta será com o código HTTP 200 e um json com os dados do carrinho e do usuário, exatamente igual ao retorno da criação do carrinho.

Entretanto, se o usuário informado na URL não for encontrado no banco de dados, o retorno será o código HTTP 404 Not Found e a mensagem exibida é:

```json
{
  "detail": "Este id não possui carrinho aberto!"
}
```
Caso haja a desistência da compra de um produto, o usuário final conseguirá removê-lo de seu carrinho. Para isso é executada a requisição DELETE /api/cart/<user_id>/<product_code>. Ao finalizar a remoção, o código retornado é o HTTP 200 OK, com a confirmação:

```json
{
  "description": "Produto removido do carrinho com sucesso!",
  "result": null
}
```

Se alguma das informações solicitadas não estiver correta será retornado código HTTP 404 Not Found e as mensagens possíveis são:

```json
{
  "detail": "Não existe produto com o código informado!"
}
ou
{
  "detail": "Este usuário não existe ou não possui carrinho aberto."
}
```
Havendo a desistência de toda a compra, o endpoint utilizado será o DELETE /api/cart/<user_email>. Para confirmar que já não existe um carrinho disponível:

```json
{
  "description": "Carrinho deletado com sucesso!",
  "result": null
}
```
Em uma situação de exceção, o código será HTTP 404 Not Found e a mensagem retornada será: 

```json
{
  "detail": "Este usuário não existe ou não possui carrinho aberto."
}
```
Entretanto, se a compra for finalizada, usaremos alguns passos de todas as etapas anteriores, como por exemplo a criação do usuário, do endereço e do produto. É essencial que o banco já esteja populado com estas informações para que seja possível a criação do pedido.

O método utilizado para fechar um pedido é o POST /api/cart/<user_email> e o código esperado para a confirmação de que o pedido foi gerado é o HTTP 200 OK, acompanhando da descrição:

```json
{
  "description": "Pedido criado com sucesso!",
  "result": null
}
```
Caso algum dos passos anterirores não tenham sido executados, as mensagens de retorno poderão ser:

```json
HTTP 404 Not Found:
{
  "detail": "Este usuário não existe ou não possui carrinho aberto."
}
ou HTTP 203
{
  "detail": "Este usuário ainda não possui um endereço cadastrado"
}
```

<h3 id="formulando-pedido-fechado">Formulando um pedido fechado</h3>

Quando o carrinho é finalizado, um pedido é gerado. Isso significa que o usuário finalizou a sua compra com a LuizaPets e quando após a criação de um pedido é possível obter algumas informações relacionadas a ele. 

As classes relacionadas ao pedido estão registradas no arquivo order.py, dentro da pasta "schemas". A classe criada para a formação, também herdou a classe criada para o usuário e a para o endereço.

Há também outras classes para que seja possível obter o produto como resposta para a sua manipulação.

Na pasta "rules", o arquivo order_rules.py contém as regras para que um usuário possa consultar seus pedidos e rever os produtos e suas quantidades.

Em "models", criamos o order.py contém as funções de conexões com o banco de dados, para que as funções definidas anteriormente tenham efeito também no banco.

Por fim, as rotas que permitem que as requisições sejam efetuadas ficam localizadas na pasta "controllers", no arquivo routes_order_async.py, assim como nas demais etapas.

Para auxiliar com as requisições do pedidos, usamos o arquivo cases_test_order.http, que abriga os esboços da API.

##Instruções para formular um pedido

Após garantir que a aplicação está preparada para rodar e com a conexão com o Mongo ativa, será necessário garantir que ao menos um pedido já esteja finalizado, o que significa que algumas etapas precisarão ter sido executadas:

- Criação de ao menos um usuário na loja;
- Criação de ao menos um endereço ao usuário cadastrado;
- Criação de ao menos um produto;
- Criação de um carrinho de compras;
- Finalizar o carrinho de compras do usuário.

Se desejar, um usuário, poderá consultar uma lista dos pedidos que ele já possui com a LuizaPets. Para isso, ele deverá utilizar o método GET /api/oder/<user_e-mail>/skip/{skip}/limit/{limit}>.

O retorno do endpoint de consulta será com o código HTTP 200 e uma lista com os dados de todos os já realizados, até o limit estabelecido na URL:

```json
{
  "description": "OK",
  "result": [
    {
      "_id": "<_id>",
      "user": {
        "_id": "<_id>",
        "name": "<name>",
        "email": "<email>",
        "password": "<password>",
        "is_active": "<is_active",
        "is_admin": "<is_admin>"
      },
      "price": "<price>",
      "paid": "<false>",
      "create": "<create>",
      "address": {
        "street": "<street>",
        "number": "<number",
        "zipcode": "<zipcode",
        "district": "district",
        "city": "<city",
        "state": "<state",
        "is_delivery": "is_delivery"
      },
      "authority": "<authority>",
      "order_items": [
        {
          "product": {
            "_id": "<_id>",
            "name": "<name>",
            "description": "<description>",
            "price": "<price>",
            "image": "<image>",
            "code": "<code>",
            "type_animal": "<type_animal>",
            "category": "<category>",
            "qt_stock": "<qt_stock>",
          },
        "qtd_product": "<qtd_product>"
        }
      ],
    }
}
```
Entretanto, se o e-mail do usuário informado na URL não for encontrado no banco de dados, o retorno será o código HTTP 404 Not Found e a mensagem exibida é:

```json
{
  "detail": "Este usuário não possui cadastro ou o e-mail informado está incorreto!"
}
```
Além da consulta dos pedidos, é possível visualizar a quantidade de pedidos que já foram realizados. Para isso, basta utilizar a requisição GET /api/order/count/<user_email>. O retorno, caso todos os parâmetros estejam corretos deverá ser HTTP 200

```json
{
  "description": "OK",
  "result": "<qtd_orders>"
}
```
Porém, se alguma das informações solicitadas não estiver correta será retornado código HTTP 404 Not Found e a mensagem será:

```json
{
  "detail": "Este usuário não possui cadastro ou o e-mail informado está incorreto!"
}
```
A última consulta disponível é para rever quais os produtos e as quantidades que foram inseridas no pedido. A requisição é realizada também pelo método GET /api/order/items/<order_id>. O retorno, caso o pedido já tenha sido criado será:

```json
HTTP 200 OK
{
  "description": "OK",
  "result": [
    {
      "product": {
        "_id": "<_id>",
        "name": "<name>",
        "description": "<description>",
        "price": "<price>",
        "image": "<image>",
        "code": "<code>",
        "type_animal": "<type_animal>",
        "category": "<category>",
        "qt_stock": "<qt_stock>"
      },
      "qtd_product": "<qtd_product>"
    }
  ]
}
```
Do contrário, se não houver um pedido com o order_id informado na requisição, será devolvido o código HTTP 404 Not Found e a mensagem:

```json
{
  "detail": "O número de pedido informado não está correto"
}
```

<h3 id="testando-o-projeto">Testando o projeto</h3>

Antes de iniciar os testes do projeto, será necessário realizar algumas instalações.

Para começar, faremos a instalação do pytest:

```
$ pip install -U pytest
```
Finalizando a instalação do pytest, crie um arquivo pytest.ini dentro da pasta "tests", para que ele funcione como o arquivo .env.example.txt que está na raiz do projeto. Dentro deste arquivo você informará:

```
[pytest]
env = 
    DATABASE_URI=mongodb+srv://<seuusuario>:<suasenha>@projetofinal-luizacode.wj3w8ev.mongodb.net/test
```
Após a criação do pytest.ini, cole o comando abaixo em seu terminal:

```
$ pytest -c .\tests\pytest.ini --cov-config=.coveragerc --cov-report xml:tests\coverage\cov.xml --cov=. tests/
```
Quando o comando acima terminar de ser executado, será criado automaticamente um arquivo cov.xml na pasta "coverage" que se encontra dentro da pasta "tests".

Com todas as configurações realizadas, bastará abrir o terminal e colar o comando abaixo:

```
$ pytest tests
```
Após a execução, no terminal, na aba de saída, será exibida a porcentagem de testes que passaram ou falharam.

<h3 id="tecnologias-utilizadas">Tecnologias utilizadas</h3>

<p>
Para o desenvolvimento da aplicação, utilizamos as seguintes tecnologias:

• VSCode: Editor de código fonte para criação da aplicação;</br>
• Trello: Para organização das tarefas a serem desenvolvidas;</br>
• Slack: Comunicação entre o time;</br>
• Whatsapp: Comunicação entre o time;</br>
• Zoom: App para vídeo conferência onde foram ministradas as aulas e onde foi realizado parte do projeto;</br>
• Google Meet: App para vídeo conferência usado para o desenvolvimento do projeto em conjunto;</br>
• Python 3.10.7: Linguagem utilizada na programação da aplicação;</br>
• MongoDB: Banco de dados não relacional utilizado para abrigar os dados criados ao rodar a aplicação;</br>
• Studio 3T: Plataforma utilizada para facilitar a manipulação dos dados no banco;</br>
• FastAPI: Framework utilizado para realizar as requisições e criar o swagger;</br>
• Uvicorn: Utilizado para subir o servidor para que as rotas do FastAPI pudessem ser acessadas;</br>
• Docker: Plataforma para para conteinerizar a aplicação, para que ela se tornasse portátil para o Heroku;</br>
• Heroku: Utilizado para que fosse possível fazer o deploy da aplicação e, dessa forma, disponibilizá-la para os avaliadores.
</p>

<h3 id="pessoas-contribuidoras">Pessoas Contribuidoras</h3>

Neste momento, gostaríamos de formalmente agradecer a todos os professores, parças técnicos e madrinhas/padrinhos que estiveram envolvidos no projeto LuizaCode - 5ª edição, pois todos, a sua maneira, contribuíram efetivamente para que esta aplicação fosse executada com êxito.

Também gostaríamos de agradecer a organização do Bootcamp, em especial a Taci e Débora, que estiveram coordenando todas as etapas do curso, sempre encorajando e confortando todas as participantes.

<h3 id="conclusao">Conclusão</h3>

Concluímos, como um time, que demos mais um passo em direção a carreira por todas almejada, a do desenvolvimento, seja ele front-end ou back-end.

Todas as etapas do bootcamp, sobretudo a realização do projeto final, nos proporcionou vivenciar algo similar ao dia a dia de um time de desenvolvimento.

Para além da vivência, conseguimos solidificar conhecimentos chave, que serão primordiais para que possamos continuar a nos desenvolver profissionalmente, tais como a criação e estanciamento de classes, criar uma aplicação que já possua API disponível para ser utilizada, realizar conexões e manipular banco de dados, dentre outros.
